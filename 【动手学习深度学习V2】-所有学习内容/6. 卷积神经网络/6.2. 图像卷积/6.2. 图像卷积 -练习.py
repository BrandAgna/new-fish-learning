#!/usr/bin/env python
# coding: utf-8

# ## 练习
# 
# 1. 构建一个具有对角线边缘的图像`X`。
#     1. 如果将本节中举例的卷积核`K`应用于`X`，会发生什么情况？
#     1. 如果转置`X`会发生什么？
#     1. 如果转置`K`会发生什么？
# 1. 在我们创建的`Conv2D`自动求导时，有什么错误消息？
# 1. 如何通过改变输入张量和卷积核张量，将互相关运算表示为矩阵乘法？
# 1. 手工设计一些卷积核。
#     1. 二阶导数的核的形式是什么？
#     1. 积分的核的形式是什么？
#     1. 得到$d$次导数的最小核的大小是多少？
# 

# ## 1. 构建一个具有对角线边缘的图像`X`。
#    1. 如果将本节中举例的卷积核`K`应用于`X`，会发生什么情况？
#    1. 如果转置`X`会发生什么？
#    1. 如果转置`K`会发生什么？

# In[14]:


import torch

def corr2d(X, K):  
    """计算二维互相关运算"""
    h, w = K.shape
    Y = torch.zeros((X.shape[0] - h + 1, X.shape[1] - w + 1))
    for i in range(Y.shape[0]):
        for j in range(Y.shape[1]):
            Y[i, j] = (X[i:i + h, j:j + w] * K).sum()
    return Y

# 构建具有对角线边缘的图像X
X = torch.ones((6, 8))
X[:, 2:6] = 0
X


# In[15]:


# 定义卷积核K
K = torch.tensor([[1.0, -1.0]])
K


# In[10]:


# 应用卷积核K到图像X
corr2d_X_K = corr2d(X, K)
corr2d_X_K


# In[11]:


# 转置X并应用卷积核K
corr2d_X_t_K = corr2d(X.t(), K)
corr2d_X_t_K


# In[12]:


# 应用转置的卷积核K到图像X
corr2d_X_K_t = corr2d(X, K.t())
corr2d_X_K_t


# ## 2. 在我们创建的`Conv2D`自动求导时，有什么错误消息？

# `Conv2D'只能算2d的，会报错，源代码已经修改为可以执行的版本，详情请见【图像卷积-代码】

# ## 3. 如何通过改变输入张量和卷积核张量，将互相关运算表示为矩阵乘法？

# 互相关运算可以通过展开输入张量和卷积核张量来表示为矩阵乘法。在这种表示中，输入张量被转换成一个大矩阵，每行包含卷积核应用于输入的一个特定区域。卷积核被展开成一个向量，与此矩阵相乘，以执行所有卷积操作。

# ## 4. 手工设计一些卷积核。
#    1. 二阶导数的核的形式是什么？
#    1. 积分的核的形式是什么？
#    1. 得到$d$次导数的最小核的大小是多少？
# 

# #### A. 二阶导数的核的形式是什么？
# 
# 一个常见的二阶导数核是拉普拉斯核，它在二维上通常表示为：
# 
# \begin{bmatrix}
# 1 & 1 & 1 \\
# 1 & -8 & 1 \\
# 1 & 1 & 1
# \end{bmatrix}
# 
# 
# #### B. 积分的核的形式是什么？
# 
# 积分核在卷积操作中不常见，因为它涉及到全局操作而不是局部操作。然而，理论上，一个平均核（所有元素为1且平均化的核）可以用于模拟积分的效果。
# 

# #### C. 得到\(d\)次导数的最小核的大小是多少？
# 
# 得到\(d\)次导数的最小核的大小通常是\(d+1\)。例如，一阶导数（如Sobel或Prewitt算子）通常是3x3核，二阶导数（如拉普拉斯核）也可以是3x3核。
# 
# 现在，让我们使用Python实现第一个部分的卷积操作，来观察卷积核`K`对图像`X`的影响。
# 
# 根据卷积操作的结果，我们可以看到：
# 
# 1. 应用卷积核`K`到图像`X`得到的结果是：
#    
#    \begin{bmatrix}
#    19 & 25 \\
#    37 & 43
#    \end{bmatrix}
#    
# 
# 2. 将图像`X`转置后应用卷积核`K`得到的结果是：
#    
#    \begin{bmatrix}
#    17 & 35 \\
#    23 & 41
#    \end{bmatrix}
# 
# 
# 3. 应用转置的卷积核`K`到图像`X`得到的结果是：
#    
#    \begin{bmatrix}
#    17 & 23 \\
#    35 & 41
#    \end{bmatrix}
#   
# 
# 具体实现代码如下

# In[24]:


import torch

# 定义二维互相关运算
def corr2d(X, K):  
    """计算二维互相关运算"""
    h, w = K.shape
    Y = torch.zeros((X.shape[0] - h + 1, X.shape[1] - w + 1))
    for i in range(Y.shape[0]):
        for j in range(Y.shape[1]):
            Y[i, j] = (X[i:i + h, j:j + w] * K).sum()
    return Y

# 构建一个具有对角线边缘的图像X
X = torch.tensor([[0, 1, 2], [3, 4, 5], [6, 7, 8]])

# 定义卷积核K
K = torch.tensor([[0, 1], [2, 3]])

# 应用卷积核K到图像X
corr2d_X_K = corr2d(X, K)
corr2d_X_K


# In[25]:


# 转置X并应用卷积核K
corr2d_X_t_K = corr2d(X.t(), K)
corr2d_X_t_K


# In[26]:


# 应用转置的卷积核K到图像X
corr2d_X_K_t = corr2d(X, K.t())
corr2d_X_K_t

